#!/usr/bin/env python3

import keyboard as kb
import rclpy
from rclpy.node import Node

from std_msgs.msg import String
from cv_bridge import CvBridge
from geometry_msgs.msg import Twist, Vector3


class Movement(Node):

    def __init__(self):

        remote_control = True

        #### DRONE FLIGHT SETUP ####
        drone_flying = False    
        drone_roll = 0
        drone_pitch = 0
        drone_yaw = 0
        drone_altitude = 0


        ### Initializing the node ### 
        super().__init__('movement')
        self.publisher_ = self.create_publisher(Twist, '/movement', 10) # We create a publisher to the topic "movement"
        self.publisher_2 = self.create_publisher(String,'/takeoff',10) # We create a publishet to the topic takeoff

        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback) # Every 0.5 seconds we run the timer_callback function
        self.timer = self.create_timer(timer_period, self.timer_takeoff) # Every 0.5 seconds we run the timer_takeoff function
        self.i = 0

    def timer_takeoff(self): # Function that checks if we have pressed any buttons that will initiate takeoffs and landings and publishes it if there has been
        global drone_flying

        ### Landing and takeoff ###

        if kb.is_pressed("q"):  # If we press q on the keyboard land
            self.publisher_2.publish("q") # We send our message


        if drone_flying == False and kb.is_pressed("r"):    # If we are not flying and we press r, initiate take off (off ground)
            self.publisher_2.publish("r") # We send our message 
            drone_flying = True

        if drone_flying == False and kb.is_pressed("t"):    # If we are not flyingand we press t, initiate take off (from hand?)
            self.publisher_2.publish("t") # We send our message
            drone_flying = True
        
        if drone_flying == True and kb.is_pressed("l"):     # If we are flying and we press l, land and stop flying? 
            self.publisher_.publish("l") # We send our message
            drone_flying = False

        


    ### Message containing Position ### 
    def timer_callback(self):   # Checks if we have pressed any of the movement buttons and if we have publishes the movement matrix

        #### MOVEMENT COMMANDS ####
        global drone_roll
        global drone_pitch
        global drone_yaw
        global drone_altitude
    
        
    ## WASD ##  Why are these capital when the others were not, does this make a difference? 
        if kb.is_pressed("w") and (drone_pitch == 0 or drone_pitch == -1):  # If we press w and the drone is standing still or moving backwards, move forward? 
            drone_pitch = 1
        elif not kb.is_pressed("w") and drone_pitch == 1: # If we press w and the drone is moving forward, stop moving forward?
            drone_pitch = 0

        if kb.is_pressed("s") and (drone_pitch == 0 or drone_pitch == 1):   # If we press s and the drone is currently standing still or moving forward, move backwards? 
            drone_pitch = -1
        elif not kb.is_pressed("s") and drone_pitch == -1:  #If we press s and the drone is moving backwards, stop moving backwards? 
            drone_pitch = 0

        if kb.is_pressed("a") and (drone_roll == 0 or drone_roll == 1): # If a is pressed and the drone is standing still or moving the the right, move to the left? 
            drone_roll = -1
        elif not kb.is_pressed("a") and drone_roll == -1:   # If a is pressed and the drone is moving to the left, stop moving to the left? 
            drone_roll = 0

        if kb.is_pressed("d") and (drone_roll == 0 or drone_roll == -1):    # If d is pressed and the drone is standing still or moving to the left, move to the right? 
            drone_roll = 1
        elif not kb.is_pressed("d") and drone_roll == 1:    # If d is pressed and the drone is moving to the right, stop moving to the right? 
            drone_roll = 0


        ## ARROWS ##
        # Same as WASD but just not as arrows
        if kb.is_pressed("UP") and (drone_altitude == 0 or drone_altitude == -1):
            drone_altitude = 1
        elif not kb.is_pressed("UP") and drone_altitude == 1:
            drone_altitude = 0

        if kb.is_pressed("DOWN") and (drone_altitude == 0 or drone_altitude == 1):
            drone_altitude = -1
        elif not kb.is_pressed("DOWN") and drone_altitude == -1:
            drone_altitude = 0

        if kb.is_pressed("LEFT") and (drone_yaw == 0 or drone_yaw == 1):
            drone_yaw = -1
        elif not kb.is_pressed("LEFT") and drone_yaw == -1:
            drone_yaw = 0

        if kb.is_pressed("RIGHT") and (drone_yaw == 0 or drone_yaw == -1):
            drone_yaw = 1
        elif not kb.is_pressed("RIGHT") and drone_yaw == 1:
            drone_yaw = 0
            
        #######

        self.msg = Twist(   # Sets up the movement vector
            linear = Vector3(
                x = None,
                y = None,
                z = float(drone_altitude)
            ),
            angular = Vector3(
                rotX = float(drone_roll),
                rotY = float(drone_pitch),
                rotZ = float(drone_yaw)
            )
        )

        self.publisher_.publish(self.msg) # We publish or movement vector
        self.i += 1   #Iteration number? 


###############################################################
#################    MOVEMENT FUNCTIONS    ####################
###############################################################

    #def drone_movement(self):  # is this in the loop atm? And if yes, can someone explain it to me? 
        


def main(args=None):
    rclpy.init(args=args)

    movement = Movement() # We run the movement node 

    rclpy.spin(movement)

    # Destroy the node explicitly
    # (optional - otherwise it will be done automatically
    # when the garbage collector destroys the node object)
    movement.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()